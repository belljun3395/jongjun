## 오브젝트 정리(01~03)



오브젝트는 "코드로 이해는 객체지향의 세계"라는 부제를 가지고 있습니다.

부제에서 알 수 있듯 오브젝트르 통해 객체지향에 대해 이해하는데 도움을 받고자 정리하고 있습니다.



### 객체

객체지향에 대해서 이해하려면 우선 객체가 어떤 것인지 알아야겠죠?

```
객체지향 프로그래밍에서 객체는 클래스의 인스턴스이다. 클래스 객체는 자료와 그 자료를 다루는 명령의 조합을 포함하여 객체가 메시지를 받고 자료를 처리하며 메시지를 다른 객체로 보낼 수 있도록 한다. 
```

위키에서는 객체지향에서의 객체에 대해 위와 같이 정의합니다.

위 문장에서 주목할 만한 단어는 "자료", "명령" 그리고 "메시지"라고 생각합니다.



```java
public class Member {
  private Long age;
  private String name;
  private Long weight;
  private Dog dog;
  
  public Long getAge() {...};
  public String getName() {...};
	public void boastDog(Food food) {...};
}
```

위와 같은 객체에서 **자료**는 `age` , `name` , `weight` 그리고 `dog` 와 같은 것을 의미할 것입니다.

하지만 우리가 이를 알 수 있을까요?

그렇지는 않습니다.

`private` 코드에서도 확인할 수 있듯 공개되어 있지 않습니다.



그럼 우리가 알 수 있는 것은 무엇일까요?

<u>객체가 말해주는 것입니다</u>(이를 인터페이스라고 합니다.)

`getAge()`, `getName()` 그리고 `boastDog(Food food)` 이들과 같이 객체가 말해주는 것 만을 우리는 알 수 있습니다.



그럼 이들이 정확한 정보를 제공하지 않을 수도 있지 않을까요?

어쩔 수 없습니다! 믿어야 합니다!!

객체는 자율성을 가지니까요!



그런데 `boastDog(Food food)` 는 Dog라는 자료를 가지고 있습니다.

이에 대해 조금 더 자세히 볼까요?

```java
public void boastDog(Food food) {
  if(food.isEmty) {
    dog.bark();
  } else {
    dog.smile();
  }
}
```

위의 위키에서 객체지향의 명령을 `자료를 다루는 명령` 라고 하였습니다.

Member는 dog라는 자료를 가지고 있고 `dog.bark()` 그리고 `dog.smile()`과 같이 자료를 다루는 **명령**을 하고 있습니다.



그런데 Member는 Dog를 어떻게 다룰 수 있을까요?

이 역시 Dog가 말해주는 것을 통해서만 다룰 수 있습니다.

```java
public class Dog {
  private Toy toy;
  
  public void bark() {...};
  public void smile() {...};
}
```

Dog는 자신이 가지고 있는 Toy에 관해서는 공개하지 않았네요?

이 역시 Dog의 자율적인 선택입니다.

우리는 단지 Dog가 공개한 것에 대해서만 알 수 있고 명령할 수 있습니다.



이렇게 객체는 공개된 인터페이스를 통해 협업합니다.

협업은 현실에서도 객체 사이에서도 중요합니다.

```java
public void boastDog(Food food) {
  if(food.isEmty) {
    dog.bark();
  } else {
    dog.smile();
  }
}
```

그렇기에 다시 한번 등장한 위의 코드를 보면

Member는 Dog와의 협업을 위해 Dog의 메서드인 `bark()` 그리고 `smile()`을 통해 메시지를 보내고 있는 것입니다.

Dog 역시 Member와의 협업을 위해 `bark()` 그리고 `smile()`을 통해 메시지를 수신하고 있는 것입니다.



객체에 대해서 이해하는 데 도움이 되었을까요?

해당 내용은 오브젝트 01~02를 이해한 바를 바탕으로 정리한 것으로 01~02를 통해 부족한 내용을 보충하면 좋을 것 같습니다.



### 협력

위에서 잠깐 언급하였지만, 협력은 현실에서나 객체 사이에서나 중요합니다.

책에서 협력은 아래와 같이 설명합니다.

```
협력이란 어떤 객체가 다른 객체에게 무엇인가를 요청하는 것이다.
한 객체는 어떤 것이 필요한 때 다른 객체에게 전적으로 위임하거나 서로 협력한다.
즉, 두 객체가 상호작용하여 더 큰 책임을 수행하는 것이다.
```

즉, 협력은 책임을 수행하기 위한 것이라 할 수 있습니다.



만약 위의 Member가 "강아지 자랑 대회"에 참가하였다고 생각해봅시다.

그럼 이때 Member는 "강아지 자랑 대회"라는 협력에 참여한 것이고 대회의 심사위원이 Member의 `boastDog()`에 메시지를 보내면 Member는 그 메시지를 수신하고 `boastDog()`라는 책임을 지게 되는 것입니다.

위의 예시처럼 **책임**이란 협력에 참여하기 위해 객체가 수행하는 행동이라 할 수 있겠네요! 



이렇게 넘어갈 수 있지만 한 번만 Member와 심판의 협력을 다시 봅시다.

만약에 Member가 Dog를 심사 전에 잃어버렸다면 어떨까요?

Member는 심판과의 협력에서 `boastDog()`라는 책임을 다할 수 없지 않을까요?

즉, Member는 Dog를 알고 있고 가지고 있을 책임도 가지고 있는 것입니다.

---

이때 알고 있다는 것든 2가지 경우가 있습니다.

1. 변수로 가지고 있는 경우
2. 매개변수로 가지고 있는 경우



이때 알고 있다는 것은 객체 사이의 의존성을 만드는데 1은 객체 사이의 강한 의존성을 2는 약한 의존성을 만듭니다.

그렇기에 이는 각 경우를 잘 분석해서 적절히 선택하여야 합니다.



저의 경우 객체의 생성 시기를 생각해보는데 생성 시기가 같고 알고 있어야 한다면 1을 그렇지 않다면 2를 선택하는 편입니다.

---



다시 한번 책임을 정의해볼까요?

**책임**은 협력에 참여하기 위해 객체가 알고 있고 할 수 있는 것이라 할 수 있겠네요!



### 역할

그럼 역할은 무엇일까요?

**역할**은 객체가 어떤 측정한 협력 안에서 수행하는 책임의 집합입니다.

하나의 책임을 여러 객체가 가지고 있다면 그때 책임은 역할이 되는 것입니다.



역할은 객체가 참여할 수 있는 일종의 슬롯이라 할 수 있습니다.

그렇기에 역할은 공통의 책임을 바탕으로 객체의 종류를 숨기기 때문에 이런 관점에서 역할을 객체의 추상화로 볼 수 있고 합니다.



### 정리

정리해보면 객체지향은 협력에서 시작한다고 볼 수 있습니다.

협력에서 필요한 메시지를 만들고 이를 전달할 객체를 찾습니다.

메시지를 수신한 객체는 이제 책임을 집니다.

이때 객체는 책임을 자율적으로 수행합니다.



즉, 우리가 객체지향을 위해 할 것은 협력을 잘 파악하여 메시지를 만들고 이를 적절한 객체에 전달하는 것이라 할 수 있습니다.
