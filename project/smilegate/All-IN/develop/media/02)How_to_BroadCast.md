## How to Broad Cast

우선 방송 송출 과정에 대해서 알아보자.

그 전에 우선 방송을 위해 필요한 DB는 다음과 같다.

![방송스트리밍필요DB](https://user-images.githubusercontent.com/102807742/211821187-c95a842a-9823-4857-ac11-47a496ba0f5c.png)



이제 본격적으로 방송 송출 과정에 대한 설명을 시작한다.

방송 송출을 하기 위해서는 우선 방송을 송출할 주소가 필요할 것이다.

그렇기에 방송 송출자는 우선 방송 송출 주소를 요청하여야 한다.



### 방송 송출 주소 요청

![방송URL요청](https://user-images.githubusercontent.com/102807742/211802982-fc265cb3-7a67-4a12-964d-48cc38406ac0.png)

방송 송출 주소 요청에 관한 시퀀스 다이어그램은 위와 같다.

위의 요청에서 반환되는 값의 형식은 아래와 같다.

`rtmp:{media_server_domain}/{room_id}/{live_key}`

과정을 하나하나 자세히 알아보자.

1. Producer, 즉 방송 송출자가 자신이 방송을 송출할 URL을 요청한다.
2. Producer의 id를 기반으로 room_id를 조회한다. 이때 room_id는 Now의 show 그리고 Twitch의 방송국과 같은 개념과 동일하다.
3. Producer의 id를 반환한다.
4. live_key를 생성한다. 이때 live_key의 경우 jwt 토큰 값을 통해 생성할 것이다.
5. room_id와 live_key를 가지고 Live DB에 이를 기록한다.
6. room_id와 live_key를 기반으로 방송 URL을 생성하고 반환한다.



### 방송

![방송](https://user-images.githubusercontent.com/102807742/211807504-e5a5ea33-9503-456f-a7c3-28d8e201fa6f.png)

실제 방송 과정은 위와 같다.

1. Producer가 방송 시작 요청을 한다.

2. Manager Server에서는 OBS와 소켓을 OPEN한다.

3. 방송 시작 메시지를 발행한다. 

   이때 메시지는 외부 서비스를 위해 Kafka를 통해 발행할 예정이고 이 메시지를 받는 곳은  채팅, 알림 서비스가 있고 내부 서비스는 Kafka보다는 내부 Event 발행을 통해 Live DB에 방송 시작 시간을 기록할 것이다.

4. Producer가 방송을 종료 요청을 한다.

5. Manager Server에서는 OBS와 소켓을 CLOSE한다.

6. 방송 종료 메시지를 발행한다. 이때도 3번과 동일한 대상들에게 메시지를 발행한다.

위와 같이 방송이 진행되면 좋겠지만 의도치 않게 방송이 종료 될 수도 있다.

즉, `4번 방송 종료 요청`  없이 방송이 종료될 수 있다는 것이다.

이때는 Manager Server가 OBS와 소캣 연결되어 있기에 방송이 종료되었다는 것을 감지할 수 있고(관련 API 추가 확인 필요) 이를 통해 4번 과정을 제외하고 이후 과정을 수행하면 문제가 없을 것 같다.



### Media Server

![방송스트리밍](https://user-images.githubusercontent.com/102807742/211817502-425bd40f-30fc-4971-a316-6446ddb0f53b.png)

위는 방송 시작 요청 메시지를 Medaia Server가 받아 어떻게 그것을 활용하고 방송 송출을 어떠한 방식으로 이루어지는 설명하는 사진이다.

우선 방송 시작 요청 메시지를 받으면 검증 로직이 추가가 된다.

이때 검증이란 Publisher가 올바른 주소로 방송을 송출하는지를 검증하는 것이다. 

(추후 하나의 주소로는 하나의 OBS에서만 송출할 수 있도록 제약도 추가할 것이다.)

이 검증 과정을 추가한 이유는 만약 이를 검증하지 않는다면 앞서 제공한 방송 송출 주소를 가지고 있는 누구나 방송을 송출할 수 있게 되기 때문이다.

그렇기에 이 검증 로직을 어떤 서버의 역활로 할당할지 고민이 된다.

아직 RTMP 요청이 정확히 어떤 방식으로 통신하는지 알지 못해서 생기는 고민인거 같다.

만약 RTMP 요청이 소켓과 같이 한번 연결하고 그것이 **유지되는 방식**의 통신을 한다면 검증 로직을 Media Server 외부에 두어도 괜찮겠다는 생각이든다.

하지만 그렇지 않고 HTTP 요청과 같은 것이 **계속해서 요청하는 방식**이라면 이는 Media Server 내부에 검증 로직을 두어야겠다는 생각이 든다.



